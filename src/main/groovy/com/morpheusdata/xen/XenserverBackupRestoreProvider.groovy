package com.morpheusdata.xen

import com.morpheusdata.core.MorpheusContext
import com.morpheusdata.core.backup.BackupRestoreProvider
import com.morpheusdata.core.backup.response.BackupRestoreResponse
import com.morpheusdata.model.Cloud
import com.morpheusdata.model.ComputeServer
import com.morpheusdata.response.ServiceResponse;
import com.morpheusdata.model.BackupRestore;
import com.morpheusdata.model.BackupResult;
import com.morpheusdata.model.Backup;
import com.morpheusdata.model.Instance
import com.morpheusdata.xen.util.XenComputeUtility
import groovy.util.logging.Slf4j

@Slf4j
class XenserverBackupRestoreProvider implements BackupRestoreProvider {

	XenserverPlugin plugin
	MorpheusContext morpheusContext

	XenserverBackupRestoreProvider(XenserverPlugin plugin, MorpheusContext morpheusContext) {
		this.plugin = plugin
		this.morpheusContext = morpheusContext
	}
	
	/**
	 * Returns the Morpheus Context for interacting with data stored in the Main Morpheus Application
	 * @return an implementation of the MorpheusContext for running Future based rxJava queries
	 */
	MorpheusContext getMorpheus() {
		return morpheusContext
	}

	/**
	 * Add additional configurations to a backup restore. Morpheus will handle all basic configuration details, this is a
	 * convenient way to add additional configuration details specific to this backup restore provider.
	 * @param backupResultModel backup result to be restored
	 * @param config the configuration supplied by external inputs
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse configureRestoreBackup(BackupResult backupResult, Map config, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Build the configuration for the restored instance.
	 * @param backupResultModel backup result to be restored
	 * @param instanceModel the instance the backup was created from, if it still exists. Retained backups will not have a reference to the instance.
	 * @param restoreConfig the restore configuration generated by morpheus.
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getBackupRestoreInstanceConfig(BackupResult backupResult, Instance instanceModel, Map restoreConfig, Map opts) {
//		return ServiceResponse.success()
		return ServiceResponse.success(restoreConfig)
//		log.debug "getBackupRestoreInstanceConfig: ${backupResult}, ${instanceModel}, ${opts}"
//		log.info "RAZI1 :: getBackupRestoreInstanceConfig: ${backupResult}, ${instanceModel}, ${opts}"
//		log.info("RAZI :: getBackupRestoreInstanceConfig: ${backupResult}, ${instanceModel}, ${opts}")
//		def rtn = [success:false, data:[:]]
//		try {
//			def backup = backupResult.backup
//			def instanceOpts = [:]
//			def layoutId = backupResult.instanceLayoutId ?: backup.instanceLayoutId ?: instanceModel?.layout?.id
//			def planId = backupResult.planId ?: backup.servicePlanId ?: instanceModel?.plan?.id ?: opts.plan?.id
//
////			def container = Container.get(backup.containerId)
////			def container = morpheusContext.async.workload.get(backup.containerId).blockingGet()
////			def containerConfig = container?.getConfigProperties() ?: backup.getConfigProperty('containerConfig')
////			def instanceLayout = InstanceTypeLayout.read(layoutId)
//			def instanceLayout = morpheusContext.async.instanceTypeLayout.get(layoutId).blockingGet()
////			def newLayout = instanceLayout?.cloneLayoutId ? InstanceTypeLayout.read(instanceLayout.cloneLayoutId) : instanceLayout
//			def newLayout = instanceLayout?.cloneLayoutId ? morpheusContext.async.instanceTypeLayout.get(instanceLayout.cloneLayoutId).blockingGet() : instanceLayout
////			def newPlan = ServicePlan.read(planId)
//			def newPlan = morpheusContext.async.servicePlan.get(planId).blockingGet()
////			def availablityZone = containerConfig?.availabilityZone //not needed
////			def securityGroupId = containerConfig?.securityGroupId //not needed
//			instanceOpts.instance = [account:backup.account, instanceType:newLayout?.instanceType, layout:newLayout,
//									 plan:newPlan, name:opts.name ?: (instanceModel ? instanceModel.name + ' clone' : backup.name),
//									 site:[id:(opts.siteId ?: instanceModel.site.id)],
//									 createdBy:[id:opts.userId]]
//			instanceOpts.servicePlan = newPlan.id
//			// adhere to custom options
//			instanceOpts.servicePlanOptions = [maxMemory:backupResult.maxMemory ?: instanceModel?.maxMemory,
//											   maxStorage:instanceModel?.maxStorage, maxCores:backupResult.maxCores ?: instanceModel?.maxCores, coresPerSocket: backupResult.coresPerSocket ?: instanceModel?.coresPerSocket]
//			/*instanceOpts.vmwareResourcePoolId = container?.server?.resourcePool?.externalId
//			instanceOpts.scvmmResourcePoolId = container?.server?.resourcePool?.externalId
//			instanceOpts.azureResourceGroupId = container?.server?.resourcePool?.externalId
//			instanceOpts.resourcePoolId = container?.server?.resourcePool?.externalId*/
//			instanceOpts.volumes = opts.volumes ?: backupResult?.volumesMap?.clone() ?: instanceModel?.volumesMap?.clone()
//			instanceOpts.networkInterfaces = opts.networkInterfaces ?: backupResult.interfacesMap?.clone()  ?: instanceModel?.interfacesMap?.clone()
//			instanceOpts.storageController = opts.storageController ?: backupResult.controllersMap?.clone()  ?: instanceModel?.controllersMap?.clone()
////			instanceOpts.osExternalNetworkId = backupResult.getConfigProperty('containerConfig')?.osExternalNetworkId ?: backupInstance?.getConfigProperty('osExternalNetworkId')
////			instanceOpts.securityGroup = backupResult.getConfigProperty('containerConfig')?.securityGroup ?: backupInstance?.getConfigProperty('securityGroup')
//			log.info("RAZI :: opts.zoneId: ${opts.zoneId}")
//			if(opts.zoneId) {
//				instanceOpts.zoneId = opts.zoneId
//			}
//			/*if(availablityZone) {
//				instanceOpts.availabilityZone = availablityZone
//			}
//			if(securityGroupId) {
//				instanceOpts.securityGroupId = securityGroupId
//			}*/
//			instanceOpts.provisionOpts = [backupSetId:backupResult.backupSetId]
//			log.info("RAZI :: instanceOpts: ${instanceOpts}")
//			rtn.success = true
//			rtn.data.instanceOpts = instanceOpts
//		} catch(e) {
//			log.error("getBackupRestoreInstanceConfig error: ${e}", e)
//		}
//		return ServiceResponse.create(rtn)
	}

	/**
	 * Verify the backup restore is valid. Generally used to check if the backup and instance are both in a state
	 * compatible for executing the restore process.
	 * @param backupResultModel backup result to be restored
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse validateRestoreBackup(BackupResult backupResult, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Get restore options to configure the restore wizard. Although the {@link com.morpheusdata.core.backup.BackupProvider } and
	 * {@link com.morpheusdata.core.backup.BackupTypeProvider} supply configuration, there may be situations where the instance
	 * configuration will determine which options need to be presented in the restore wizard.
	 * <p>
	 * Available Restore options:
	 * 		<ul>
	 * 		 	<li>
	 * 		 	    restoreExistingEnabled (Boolean) -- determines the visibility of the restore to existing option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	restoreNewEnabled (Boolean) -- determines the visibility of the restore to new option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	name (String) -- default name of the restored instance
	 * 		 	</li>
	 * 		 	<li>
	 * 		 		hostname (String) -- default hostname of the restored instance
	 * 		 	</li>
	 * 		</ul>
	 *
	 * @param backupModel the backup
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getRestoreOptions(Backup backup, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Execute the backup restore on the external system
	 * @param backupRestoreModel restore to be executed
	 * @param backupResultModel refernce to the backup result
	 * @param backupModel reference to the backup associated with the backup result
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse restoreBackup(BackupRestore backupRestore, BackupResult backupResult, Backup backup, Map opts) {
		log.debug("restoreBackup {}", backupResult)
		ServiceResponse rtn = ServiceResponse.prepare(new BackupRestoreResponse(backupRestore))
		try{
			def snapshotId = backupResult.snapshotId
			def vmId = backupResult.getConfigProperty("vmId")
			if(snapshotId) {
				def sourceWorkload = plugin.morpheus.async.workload.get(opts?.containerId ?: backupResult.containerId).blockingGet()
				ComputeServer computeServer = sourceWorkload.server
				Cloud cloud = computeServer.cloud
				Map authConfig = plugin.getAuthConfig(cloud)
				//execute restore
				def restoreResults = XenComputeUtility.restoreServer(authConfig, snapshotId)
				log.debug("restore results: {}", restoreResults)
				if(restoreResults.success){
					rtn.data.backupRestore.status = BackupResult.Status.SUCCEEDED
					rtn.data.updates = true
					rtn.success = true

					//restore stops the vm, so need to restart it
					def startVm = XenComputeUtility.startVm(authConfig, vmId)
				} else {
					rtn.data.backupRestore.status = BackupResult.Status.FAILED
					rtn.data.updates = true
				}
			}
		} catch(e) {
			log.error("restoreBackup: ${e}", e)
			rtn.msg = e.getMessage()
			rtn.success = false
		}
		return rtn
	}

	/**
	 * Periodically check for any updates to an in-progress restore. This method will be executed every 60 seconds for
	 * the restore while the restore has a status of `START_REQUESTED` or `IN_PROGRESS`. Any other status will indicate
	 * the restore has completed and does not need to be refreshed. The primary use case for this method is long-running
	 * restores to avoid consuming resources during the restore process.
	 * @param backupRestore the running restore
	 * @param backupResult backup result referencing the backup to be restored
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse refreshBackupRestoreResult(BackupRestore backupRestore, BackupResult backupResult) {
		return ServiceResponse.success()
	}
}
